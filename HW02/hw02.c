#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include "hw02.h"

/* https://linux.die.net/man/7/utf8
   функция кодирования номера символа в Юникоде в необходимую последовательность байт. Аргументы:
   s - указатель на элемент полученный из массива utf_table[256] соответствующих функций iso88595_to_utf8, koi8r_to_utf8, cp1251_to_utf8
   p - указатель на буфер для записи; len - длина октета. */
void to_utf8(uint16_t *s, uint8_t *p, uint8_t *len) {
	/* если код символа < 0x80, то записываем символ как есть (т.к. все вышеперечисленные кодировки совмести с ASCII до символа с кодом 0x80) */
	if (*s < 0x80) {
		p[0] = *s;
		/* октет равен 1 */
		*len = 1;
	}
	/* если код символа < 0x800, то необходимо выполнить преобразования символа из переменной s в последовательность байт вида (см. man выше):
	   0x00000080 - 0x000007FF:
			110xxxxx 10xxxxxx
		где x - биты символа из переменной s */
	else if (*s < 0x800) {
		/* сдвинем младшие 6 бит вправо и выполним побитовое ИЛИ для приведения числа к виду 110xxxxx */
		p[0] = *s >> 6 | 0xc0;
		/*  побитовое И для получения младших 6 бит, затем ИЛИ с 0x80 для приведения числа к виду 10xxxxxx */
		p[1] = (*s & 0x3f) | 0x80;
		/* октет равен 2 */
		*len = 2;
	}
	/* если код символа < 0x10000, то необходимо выполнить преобразования символа из переменной s в последовательность байт вида (см. man выше):
		0x00000800 - 0x0000FFFF:
		1110xxxx 10xxxxxx 10xxxxxx 
	    где x - биты символа из переменной s 
		Принцип работы битовых операций аналогичен примерам выше, только теперь нужно сформировать последовательность из 3 байт
	 */
	else if (*s < 0x10000) {
		p[0] = *s >> 12 | 0xe0;
		p[1] = *s >> 6 & 0x3f | 0x80;
		p[2] = *s & 0x3f | 0x80;
		*len = 3;
	}
	/* если код символа < 0x10000, то необходимо выполнить преобразования символа из переменной s в последовательность байт вида (см. man выше):
		0x00010000 - 0x001FFFFF:
		11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 
	    где x - биты символа из переменной s 
		Принцип работы битовых операций аналогичен примерам выше, только теперь нужно сформировать последовательность из 4 байт
	 */
	else if(*s < 0x200000 ) {
		p[0] = *s >> 18 | 0xf0;
		p[1] = *s >> 12 & 0x3f | 0x80;
		p[2] = *s >> 6 & 0x3f | 0x80;
		p[3] = *s & 0x3f | 0x80;
		*len = 4;
	}
}

/* функция преобразования iso-8859-5 в utf-8 с аргументами:
   c - указатель на считанный символ (см. вызов функции cp1251_to_utf8 в main) 
   p - указатель на буфер для записи байта utf символа (см. вызов функции cp1251_to_utf8 в main) 
   len - длина октета (см. вызов функции cp1251_to_utf8 в main) */
void iso88595_to_utf8(int *c, uint8_t *p, uint8_t *len) {
    /* переменной s присваивается символ из массива utf_table (код символа в Юникоде) */
    uint16_t s = iso88595_table[*c];
    
    /* функция to_utf8 для преобразования кода символа utf в набор байт с аргументами:
		s - код символа из массива utf_table; p - указатель на буфер для записи байта utf символа;
		len - длина октета */
    to_utf8(&s, p, len);
}

/* функция преобразования koi8r в utf-8 с аргументами:
   c - указатель на считанный символ (см. вызов функции cp1251_to_utf8 в main) 
   p - указатель на буфер для записи байта utf символа (см. вызов функции cp1251_to_utf8 в main) 
   len - длина октета (см. вызов функции cp1251_to_utf8 в main) */
void koi8r_to_utf8(int *c, uint8_t *p, uint8_t *len) { 
    /* переменной s присваивается символ из массива utf_table (код символа в Юникоде) */
    uint16_t s = koi8r_table[*c];

	/* функция to_utf8 для преобразования кода символа utf в набор байт с аргументами:
		s - код символа из массива utf_table; p - указатель на буфер для записи байта utf символа;
		len - длина октета */
	to_utf8(&s, p, len);
}

/* функция преобразования cp1251 в utf-8 с аргументами:
   c - указатель на считанный символ (см. вызов функции cp1251_to_utf8 в main) 
   p - указатель на буфер для записи байта utf символа (см. вызов функции cp1251_to_utf8 в main) 
   len - длина октета (см. вызов функции cp1251_to_utf8 в main) */
void cp1251_to_utf8(int *c, uint8_t *p, uint8_t *len) {
	/* переменной s присваивается символ из массива utf_table (код символа в Юникоде) */
    uint16_t s = cp1251_table[*c];
   
	/* функция to_utf8 для преобразования кода символа utf в набор байт с аргументами:
		s - код символа из массива utf_table; p - указатель на буфер для записи байта utf символа;
		len - длина октета */
	to_utf8(&s, p, len);
}

/* вывод информации о запуске программы и необходимых аргументах для ее корректной работы */
void usage() {
		printf("USAGE: ./hw02 <source file> <encoding> <dest. file>\n");
		printf("<source file> - any text file existing in FS\n");
		printf("<encoding> - one of cp1251, koi8-r, iso-8859-5\n");
		printf("<dest. file> - new file name\n");
}

/* функция проверяет правильность переданных аргументов */
int check_arguments(int *elements, char *arguments[]){
	/* если число аргументов < 4, то вывеси сообщение об ошибке и вернуть 1 (ошибка) */
	if (*elements < 4){
		printf("Error! Not enough arguments:\n");
		usage();
		return 1;
	}
	/* если в качестве src. file передан файл, которого нет, то вывести ошибку и вернуть 1 (ошибка) */
	if (access(arguments[1], F_OK) != 0) {
		perror(arguments[1]);
		usage();
		return 1;
	}
	/* если аргумент отвечающий за название кодировки написан неправильно\неполно и т.п., то вывести сообщение об ошибке */
	if ( (strcmp(arguments[2],"cp1251") == 0) ||
		 (strcmp(arguments[2],"koi8-r") == 0) ||
		 (strcmp(arguments[2],"iso-8859-5") == 0) ) {
		return 0;
	}
	else {
		printf("Error! check <encoding> argument!\n");
		usage();
		return 1;
	}
	
	return 0;
}

int main(int argc, char *argv[]) {
	FILE *fin, *fout;				/* указатели на файлы, fin - src. file. fout - dest. file */
	int c = 0;						/* c - очередной считаный символ из файла, enc_t - номер кодировки из которой будем декодировать в UTF-8  */
	uint8_t buffer[4], len = 0;		/* buffer[4] - записываем полученные байты UTF символа. len - длина октета */
	void (*enc_t)(int *, uint8_t *, uint8_t *); /* указатель на одну из функций преобразования символа одной из кодировок в UTF-8 */
	
	/* проверить переданные программе аргументы на правильность через функцию check_arguments 
	   если функция вернула -1, то аргументы переданые не все\неправильно и т.п.
		*/
	if (check_arguments(&argc, argv) == 1) {
		exit(1);
	}
	
	/* открыть файл argv[1] в режиме чтения
		показать ошибку, если произошли проблемы при открытии */
	if ((fin = fopen(argv[1], "r")) == NULL) { 
        perror("ERROR");
        exit(1);
    }
    
    /* открыть файл argv[3] в режиме записи
		показать ошибку, если произошли проблемы при открытии */
    if ((fout = fopen(argv[3], "w")) == NULL) { 
        perror("ERROR");
        exit(1);
    }
    
    /* выясним из какой кодировки нужно будет выполнять преобразования.
	   установим указатель на нужную функцию */
    if (strcmp(argv[2],"cp1251") == 0) { enc_t = &cp1251_to_utf8; }
	else if (strcmp(argv[2],"koi8-r") == 0) { enc_t = &koi8r_to_utf8;}
	else { enc_t = &iso88595_to_utf8; }
    
    /* пока не достигнем конца файла */
    while ((c = fgetc(fin)) != EOF) {
		/* в зависимости от типа кодировки вызываем соответствующую функцию со следующими аргументами:
		   c - очередной считанный символ; buffer - буфер для записи полученных байт; len - количество октетов */		
		(*enc_t)(&c, buffer, &len);

		/* если длина октета == 1, то записываем 1 байт полученного utf кода символа в файл */
		if (len == 1){
			fwrite(buffer, sizeof(uint8_t), 1, fout);
		}
		/* если длина октета == 2, то записываем 2 байта полученного utf кода символа в файл */
		if (len == 2) {
			fwrite(buffer, sizeof(uint8_t), 2, fout);
		}
		/* если длина октета == 3, то записываем 3 байта полученного utf кода символа в файл */
		if (len == 3) {
			fwrite(buffer, sizeof(uint8_t), 3, fout);
		}
		/* если длина октета == 4, то записываем 4 байта полученного utf кода символа в файл */
		if (len == 4) {
			fwrite(buffer, sizeof(uint8_t), 4, fout);
		}
	}
		
	fclose(fin);
	fclose(fout);
	
	return 0;
}
